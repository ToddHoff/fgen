#ifndef _SyncSmBase_h_
#define _SyncSmBase_h_

// Abstract state machine class for state machine "SyncSmBase".
//
// NOTE: this code is auto generated. Your changes will be 
// written over. Derive from the base class to make changes.


#include "Project/LnTypes.h"
#include "Osencap/LnTTimer.h"
#include "Util/Debug.h"
#include "Util/Log.h"
#include "Osencap/LnMutex.h"


#include "Util/Module.h"
#include "Util/Action.h"

class SyncSmBase;

/**
 * Abstract state machine class for state machine <B>SyncSmBase</B>.
 * This class was generated by the 
 * <A HREF="http://LighteraNet/main/sw/tools/fgen/fgen.html">fgen</A> state machine
 * generator.
 *
 * This is the base class for all Sync state machines.
 *
 * <H3> Base Class Usage </H3>
 *
 * It is expected a class will derive from this class and
 * implement the virtual methods to provide the state machine
 * specific behavior. State machine transitions are triggered
 * by calls to events. Events make calls to actions defined
 * in the state machine specification. Actions are implemented
 * by a derived class.
 *
 * <H3> Some State Machine Generator Tricks You may Not Know </H3>
 *
 * <H4> Mutex Generation </H4>
 * If you want a mutex generated set "IS_PROTECT 1" in the SM
 * block of the state machine specfication. 
 *
 * <H4> Debug Generation </H4>
 * Debug generation
 * can be turned on with "GEN_DEBUG 1" in the CFG
 * block of the state machine specfication. "GEN_DEBUG 0" turns
 * off debug generation. 
 *
 * <H4> Using a Module </H4>
 * Setting "IS_MODULE 1" in the CFG block
 * makes the state machine accept a module parameter in its
 * constructor. 
 *
 * <H4> Adding a Method </H4>
 * Arbitrary methods can be added to the state machine
 * with the "METHOD" directive in the SM block.
 *
 * @see <A HREF="http://LighteraNet/main/sw/tools/fgen/fgen.html">fgen documentation</A>
 */
class SyncSmBase
{
public:

   /**
    * Enum defining states in the state machine.
    */ 
   enum State
   {
      OUT_OF_SYNC,
      SYNCING,
      SYNCED
   };

   /**
    * Construct and initialize the state machine.
    *
    * @param module The module to associate with the state machine.
    *    The module is passed to debug and log macros to control
    *    the logging for the state machine.
    * @param pDebugId An ID for the state machine that is used in debug output.
    *    MEMORY: COPIED. 
    */
                           SyncSmBase(Module* module= 0, const char* pDebugId= 0);

   /**
    * Virtual destructor for the state machine. 
    *
    */
   virtual ~SyncSmBase()
   {
   }

   /**
    * Return the current state of the state machine.  When the
	* state machine first starts the previous state is set to
	* the initial state specified in the state machine specification.
    *
    * @return The current state of the state machine.
    */
   State                   CurrentState() const { return mState; }

   /**
    * Return the previous state of the state machine. When the
	* state machine first starts the previous state is set to
	* the initial state  specified in the state machine specification.
    *
    * @return The previous state of the state machine.
    */
   State                   PrevState() const { return mPrevState; }

   /**
    * Return the previous different state of the state machine. When the
	* state machine first starts the previous different state is set to
	* the initial state  specified in the state machine specification.
    *
    * @return The previous different state of the state machine.
    */
   State                   PrevDifferentState() const { return mPrevDifferentState; }

   /**
    * Return the debug id. It is used to identify the state machine in debug
    * output.
    *
    * @return The debug id. 
    */
   const RWCString&        GetDebugId() const { return mDebugId; }

// Events

   /**
    * Event GoOutOfSync. When an event is called the state machine 
    * transitions and associated actions are executed.
    *
    *
    * @return LN_OK If the state transitioned successfully. 
    * @return LN_FAIL If the state failed to transition.
    */
   LnStatus                GoOutOfSync();

   /**
    * Event DoneSyncing. When an event is called the state machine 
    * transitions and associated actions are executed.
    *
    *
    * @return LN_OK If the state transitioned successfully. 
    * @return LN_FAIL If the state failed to transition.
    */
   LnStatus                DoneSyncing();

   /**
    * Event StartSyncing. When an event is called the state machine 
    * transitions and associated actions are executed.
    *
    *
    * @return LN_OK If the state transitioned successfully. 
    * @return LN_FAIL If the state failed to transition.
    */
   LnStatus                StartSyncing();

   /**
    * Inject an event into the state machine using the name of the event.
    * The method matching the event name will be called.
    *
	* @param pEventName The name of the event.
	*
    * @return LN_OK If the event was known, 
    *    LN_FAIL If the event was not known.
    */
   virtual LnStatus        InjectEvent(const char* pEventName);

   /**
    * Return the current state as a string.
    *
    * @return The current state as a string.
    */
   virtual const char*     CurrentStateName(void) const;

   /**
    * Set the module that state machine uses to control debug.
    *
	* @param The module the state machine to use to control debug.
    */
   void                    StateMachineModule(Module& module) { mpModule= &module; }

   /**
    * Return the module that state machine uses to control debug.
    *
    * @return The module that state machine uses to control debug.
    */
   Module*                 StateMachineModule(void) const { return mpModule; }

   /**
    * Pure virtual method that must be implemented to forward an event action
	* to the correct thread context. The action's Doit method will invoke the
	* correct event on the correct state machine. Only events triggered via 
	* InjectEvent will cause a call to FwdEvent. The event invocation is 
	* encapsulated in an Action object because the event must be executed in 
	* a different thread than the call to InjectEvent. The event will trigger
	* any number of different actions that must not occur in the caller's
	* thread (generally speaking).
    *
    * @return LnStatus.
	*
	* @see Actor
	* @see #InjectEvent
    */
   virtual LnStatus        FwdEvent(Action* action) const = 0;

protected:

// Actions

   /**
    * Action MoveOutOfSync. Actions are because events happen.
    *
    *
    * @return LnStatus
    */
   virtual LnStatus        MoveOutOfSync()= 0;

   /**
    * Action MoveSyncing. Actions are because events happen.
    *
    * Application classes must implement this method with the real
     * MoveSyncing behaviour.
    *
    * @return LnStatus
    */
   virtual LnStatus        MoveSyncing()= 0;

   /**
    * Action MoveSynced. Actions are because events happen.
    *
    *
    * @return LnStatus
    */
   virtual LnStatus        MoveSynced()= 0;

// Timers

// Methods


// If


   /**
    *  Set the current state for the state machine.
    *
    * @param state The state to make the current state for the state machine.
    */
   void                    NextState(State state);

   /**
    * This method is invoked when the state machine has changed state.
	* Get the new state using CurrentState.
	* It is generated when GEN_NOTIFY_CALL is set to 1 in the fgen
	* state machine description.
	*
	* @see #CurrentState
	*/
   virtual void            SmChangedState() = 0;

protected:
   Module*                 mpModule;

private:
   State                   mState;
   State                   mPrevState;
   State                   mPrevDifferentState;
   LnMutex                 mProtection;
   RWCString               mDebugId;
   void                    DoOnExit(State state);
   void                    DoOnEntry(State state);
};



// Typedef to for a pointer to a state machine method that returns LnStatus.
typedef LnStatus (SyncSmBase::* SyncSmBaseMethodp) ();


class SyncSmBaseAction : public Action
{
public:
	SyncSmBaseAction(SyncSmBase* pSm, SyncSmBaseMethodp action)
		: mpSm(pSm), mAction(action)
	{}

	virtual void Doit(void)
	{
	   // Make the call back to the state machine event.
	   // We are invoking a pointer to a method in the sync state machine.
  	   //
	   (mpSm->* mAction)();
	   Destroy();   // get rid of the action
	}


private:
	SyncSmBase*            mpSm;
	SyncSmBaseMethodp mAction;
};


#endif // _SyncSmBase_h_
